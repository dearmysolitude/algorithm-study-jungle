# logic
#가능한 연산 아래 3가지를 가장 적게 사용해서 ,연산 최소 횟수 구하기
# X%3==0 --> X/3 또는 X%2==0 --> X/2 또는 X-1
# greedy? dp!!
# 내가 생각한 처음 최적 방법이 끝까지 반례없이 적용가능?
# 그중에서 최소를 구해야함? => dp
# 단순히 10//2 -> 5-1 -> 4//2 -> 2//2 =1 (답 4)가 아니라 
#-1해서 계산한 값이 더 큰지 바로 나눗셈으로 들어가는 값이 더 작은 지 체크를 해줘야함
#역으로 배열 순회하면서 1씩 증가해주면서 현재값이 작은지 3이나 2로 나눈 몫+1이 더 작은지 비교하기! 

N=int(input()) #1<=N<=10^6
calc=[0]*(N+1) #최소 연산값 저장할 배열, N+1해서 배열index+1굳이 안해줘도 되게
def convert_to_one(n:int)->int:
    for i in range(2,n+1):
        calc[i]=calc[i-1]+1
        if i%3==0: 
            calc[i]=min(calc[i],calc[i//3]+1)
        if i%2==0: #이전 값까지 중에서도 최소 계산 결과값 구하기 
            calc[i]=min(calc[i],calc[i//2]+1)
    return calc[n]
   
print(convert_to_one(N))

    